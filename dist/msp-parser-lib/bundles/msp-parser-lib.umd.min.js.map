{"version":3,"sources":["../../../projects/msp-parser-lib/src/lib/msp-parser-lib.service.ts","../../../projects/msp-parser-lib/src/lib/msp-parser-lib.module.ts"],"names":["http","logger","_this","this","handleName","value","spectra","nameMatch","exec","names","push","trim","meta","name","category","findCategory","handleMetaDataField","regex","extractValue","match","parsedValue","ignoreField","str","replace","inspectFields","regexInchIKey","regexSmiles","inchiKey","toLowerCase","inchi","smiles","undefined","toLocaleLowerCase","length","convertWithCallback","data","callback","debug","blockRegEx","regExAttributes","regExSpectra","regExAccurateMass","buf","toString","blocks","foundBlocks","spectrum","accurate","current","reduce","p","c","indexOf","test","warn","convertFromData","countSpectra","count","pos","MspParserLibService","i0","ɵɵinject","HttpClient","NGXLogger","factory","ɵfac","providedIn","MspParserLibModule","providers","imports","LoggerModule","forRoot","level","NgxLoggerLevel","DEBUG","serverLogLevel","OFF","HttpClientModule","i2"],"mappings":"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","sourcesContent":["import { Injectable, Inject } from '@angular/core';\nimport {HttpClient} from '@angular/common/http';\nimport {NGXLogger} from 'ngx-logger';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MspParserLibService {\n  constructor(@Inject(HttpClient) private http: HttpClient, @Inject(NGXLogger) private logger: NGXLogger) { }\n\n  /**\n   * parses the name field content and modifies the spectra object accordingly\n   */\n  handleName = (value, spectra) => {\n    // check if we have a Retention Index in the name field\n    const nameMatch = /(.+)_RI(.*)/.exec(value);\n    const nameCombinedWithInstruments = /\\s*([:\\w\\d\\s-]+);/.exec(value);\n\n    if (nameMatch) {\n      // sets the new name\n      spectra.names.push(this.trim(nameMatch[1]));\n\n      // adds it as retention index\n      spectra.meta.push(\n        {name: 'Retention Index', value: this.trim(nameMatch[2]), category: this.findCategory('Retention Index')}\n      );\n    }\n    else {\n      spectra.names.push(this.trim(value));\n    }\n\n    return spectra;\n  }\n\n  /**\n   * handles a given metadata field and might does additional modifications\n   */\n  handleMetaDataField = (value, spectra, regex, category) => {\n    if (!category) {\n      category = 'none';\n    }\n\n    const extractValue = regex;\n    let match = extractValue.exec(value);\n\n    while (match != null) {\n      const name = this.trim(match[1]);\n      const parsedValue = this.trim(match[2]);\n\n      if (this.ignoreField(name, parsedValue) === false) {\n        spectra.meta.push({name, value: parsedValue, category});\n      }\n      match = extractValue.exec(value);\n    }\n\n    return spectra;\n  }\n\n  /**\n   * simple trimming function\n   */\n  trim = (str) => {\n    return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '').replace(/^\"(.*)\"$/, '$1');\n  }\n\n  /**\n   * inspects our metadata fields and does additional modifications, as required\n   */\n  inspectFields = (match, spectra) => {\n    const regexInchIKey = /.*([A-Z]{14}-[A-Z]{10}-[A-Z,0-9])+.*/;\n    // var regexSmiles = /^([^J][0-9BCOHNSOPrIFla@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n    const regexSmiles = /^([^J][0-9A-Za-z@+\\-\\[\\]\\(\\)\\\\\\/%=#$,.~&!]{6,})$/;\n\n    // if we contain an inchi key in any propterty of this field\n    if (regexInchIKey.exec(match[2])){\n      spectra.inchiKey = regexInchIKey.exec(match[2])[1];\n    }\n\n    // get an inchi\n    else if (match[1].toLowerCase() === 'inchi' || match[1].toLowerCase() === 'inchicode' || match[1].toLowerCase() === 'inchi code') {\n      spectra.inchi = this.trim(match[2]);\n    }\n\n    // get an inchi from a smile\n    else if (match[1].toLowerCase() === 'smiles' && regexSmiles.exec(match[2])) {\n      spectra.smiles = regexSmiles.exec(match[2])[1];\n    }\n\n    // comment fields have quite often additional information in them\n    else if (match[1].toLowerCase() === 'comment') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+)\\s*=\\s*([0-9]*\\.?[0-9]+)/g, undefined);\n    }\n\n    // can contain a lot of different id's in case of massbank generated msp files\n    else if (match[1].toLowerCase() === 'searchid') {\n      spectra = this.handleMetaDataField(match[2], spectra, /(\\w+\\s?\\w*)+:\\s*([\\w\\d]+[ \\w\\d-]+)/g, 'Database Identifier');\n    }\n\n    // this mass bank special flag provides some derivatization information\n    else if (match[1].toLowerCase() === 'ms$focused_ion') {\n      spectra = this.handleMetaDataField(match[2], spectra, /\\s*(.+):(.+)/g, 'Derivatization');\n    }\n\n    // any other metadata field\n    else {\n      const name = match[1];\n      const value = match[2];\n\n      if (this.ignoreField(name, value) === false) {\n        // assign metadata\n        spectra.meta.push(\n          {\n            name,\n            value,\n            category: this.findCategory(name)\n          }\n        );\n      }\n    }\n\n    return spectra;\n  }\n\n  /**\n   * finds the related category for the given name, Will be an additional module at a later point TODO\n   */\n  findCategory = (name) => {\n    let category = 'none';\n    name = name.toLocaleLowerCase();\n\n    // mass spectral properties\n    if (name === '') {}\n\n    else if (name === 'num peaks' || name === 'retentionindex' || name === 'retentiontime') {\n      category = 'spectral properties';\n    }\n\n    // acquisition properties\n    else if (name === 'instrument' || name === 'instrumenttype' || name === 'ionmode' || name === 'precursormz') {\n      category = 'acquisition properties';\n    }\n\n    return category;\n  }\n\n  /**\n   * ignores a given field, if a certain value is not as exspected. Will be an additional module at a later point TODO\n   */\n  ignoreField = (name, value) => {\n    if (value.length === 0) {\n      return true;\n    }\n\n    name = name.toLowerCase();\n\n    if (name === 'num peaks' || name === 'numpeaks') {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * converts the data using a callback\n   */\n  convertWithCallback = (data, callback) => {\n    this.logger.debug('starting with parsing new data set...');\n\n    /**\n     * checks for a complete block of msp data.\n     */\n    const blockRegEx = /((?:.*:\\s*[^\\n]*\\n?)+)\\n((?:\\s*[0-9]*\\.?[0-9]+\\s+[0-9]*\\.?[0-9]+[;\\n]?.*\\n?)+)/g;\n\n    /**\n     * extracts the attribures like 'name' and 'value' from a found line\n     */\n    const regExAttributes = /\\s*([a-zA-Z _$\\/]+):(.+)\\s/g;\n\n    /**\n     * first block captures meta data\n     * second block caputures spectra including floats\n     * optional third block are identifications of this ion\n     */\n    const regExSpectra = /([0-9]+\\.?[0-9]*)[ \\t]+([0-9]*\\.?[0-9]+)(?:\\s*(?:[;\\n])|(?:\"?(.+)\"?\\n?))?/g;\n    // regExSpectra = /([0-9]*\\.?[0-9]+)[ \\t]+([0-9]*\\.?[0-9]+)(?:\\s*(.*)\\n?)?/g;\n    // regExSpectra = /([0-9]*\\.?[0-9]+)\\s+([0-9]*\\.?[0-9]+)(?:\\s*\"?(.*)\"?\\n)?;?/g;\n\n    /**\n     * is this an accurate mass\n     */\n    const regExAccurateMass = /([0-9]*\\.?[0-9]{3,})/;\n\n    const buf = data.toString('utf8');\n\n    let blocks = blockRegEx.exec(buf);\n\n    // return code\n    let foundBlocks = false;\n\n    // go over all available blocks\n    while (blocks != null) {\n      // contains the resulting spectra object\n      let spectra = {meta: [], names: [], spectrum: '', accurate: false};\n\n      // parse the first block and assign\n      const current = blocks[0];\n      let match = regExAttributes.exec(current);\n\n      // builds our metadata object\n      while (match != null) {\n        match[1] = this.trim(match[1]);\n        match[2] = this.trim(match[2]);\n\n        if (match[1].toLowerCase() === 'name' || match[1].toLowerCase() === 'synon') {\n          // in case there are RI encoded we extract this information\n          spectra = this.handleName(match[2], spectra);\n        } else {\n          spectra = this.inspectFields(match, spectra);\n        }\n\n        match = regExAttributes.exec(current);\n      }\n\n      // keep only unique names\n      spectra.names = spectra.names.reduce((p, c) => {\n        if (p.indexOf(c) < 0) { p.push(c); }\n        return p;\n      }, []);\n\n      // builds the actual spectra\n      match = regExSpectra.exec(blocks[2]);\n      spectra.spectrum = '';\n      spectra.accurate = true;\n\n      while (match != null) {\n        foundBlocks = true;\n\n        spectra.spectrum = spectra.spectrum + ' ' + match[1] + ':' + match[2];\n\n        // used to determine if this is an accurate mass spectra or not\n        if (!regExAccurateMass.test(match[1])) {\n          spectra.accurate = false;\n        }\n\n        if (match[3]) {\n          spectra.meta.push({\n            name: this.trim(match[3]).replace(/(^\"|\"$)/g, ''),\n            value: match[1],\n            category: 'annotation'\n          });\n        }\n\n        // get the next match\n        match = regExSpectra.exec(blocks[2]);\n      }\n\n      // assign the trimmed spectra\n      spectra.spectrum = this.trim(spectra.spectrum);\n\n      // make sure we have at least a spectrum and a name\n      if (spectra.spectrum != null && spectra.names.length > 0) {\n        // invoke the callback function\n        callback(spectra);\n      } else {\n        this.logger.warn('invalid spectra found -> ignored');\n        callback(undefined);\n      }\n\n      // fetch the next matching block\n      blocks = blockRegEx.exec(buf);\n    }\n\n    return foundBlocks;\n  }\n\n  /**\n   * converts the data using a callback\n   */\n  convertFromData = (data, callback) => {\n    return this.convertWithCallback(data, callback);\n  }\n\n  /**\n   * counts the number of mass spectra in this library file\n   */\n  countSpectra = (data) => {\n    let count = 0;\n    let pos = 0;\n\n    while (pos !== -1) {\n      count++;\n      pos = data.indexOf('Num Peaks', pos + 1);\n    }\n\n    return count;\n  }\n}\n","import {NgModule} from '@angular/core';\nimport {LoggerModule, NgxLoggerLevel} from 'ngx-logger';\nimport {MspParserLibService} from './msp-parser-lib.service';\nimport {HttpClientModule} from '@angular/common/http';\n\n@NgModule({\n  imports: [\n    LoggerModule.forRoot({\n      level: NgxLoggerLevel.DEBUG,\n      serverLogLevel: NgxLoggerLevel.OFF\n    }),\n    HttpClientModule\n  ],\n  providers: [\n    MspParserLibService\n  ]\n})\nexport class MspParserLibModule { }\n"]}